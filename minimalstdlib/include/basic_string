// Copyright 2023 Stephan Friedl. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#pragma once

#include "minstdconfig.h"

#include <string.h>

#include "algorithm"
#include "allocator"

namespace MINIMAL_STD_NAMESPACE
{
    template <typename T, size_t MAX_SIZE = DEFAULT_FIXED_STRING_MAX_SIZE>
    class basic_fixed_string;

    template <typename T, size_t MAX_SIZE = DEFAULT_DYNAMIC_STRING_MAX_SIZE>
    class basic_dynamic_string;

    template <typename T>
    class basic_string
    {
    public:
        static constexpr size_t npos = SIZE_MAX;

        typedef T ValueType;

        basic_string() = delete;
        basic_string(basic_string &&) = delete;

        basic_string &operator=(basic_string &&string_to_copy) = delete;

        ~basic_string() = default;

        basic_string &operator=(const T *value)
        {
            grow_buffer_for_string(value);

            length_ = minstd::min(strlcpy(buffer_, value, buffer_size_), max_size_);

            return *this;
        }

        basic_string &operator=(const basic_string &string_to_copy)
        {
            grow_buffer(string_to_copy.length_);

            length_ = minstd::min(strlcpy(buffer_, string_to_copy.buffer_, buffer_size_), max_size_);

            return *this;
        }

        template <size_t OTHER_MAX_SIZE>
        basic_string &operator=(const basic_fixed_string<T, OTHER_MAX_SIZE> &string_to_copy);

        template <size_t OTHER_MAX_SIZE>
        basic_string &operator=(const basic_dynamic_string<T, OTHER_MAX_SIZE> &string_to_copy);

        bool operator==(const basic_string<T> &value) const
        {
            return length_ != value.length_ ? false : (strncmp(buffer_, value.buffer_, length_) == 0);
        }

        bool operator==(const T *value) const
        {
            return (strnlen(value, buffer_size_) == length_) && (strncmp(buffer_, value, length_) == 0);
        }

        bool operator>(const basic_string<T> &value) const
        {
            return strncmp(buffer_, value.buffer_, minstd::max(length_, value.length_)) > 0;
        }

        bool operator>(const T *value) const
        {
            return strncmp(buffer_, value, minstd::max(length_, strnlen(value, buffer_size_))) > 0;
        }

        bool operator<(const basic_string<T> &value) const
        {
            return strncmp(buffer_, value.buffer_, minstd::max(length_, value.length_)) < 0;
        }

        bool operator<(const T *value) const
        {
            return strncmp(buffer_, value, minstd::max(length_, strnlen(value, buffer_size_))) < 0;
        }

        constexpr T &operator[](size_t pos)
        {
            if (pos >= length_)
            {
                return const_cast<T &>(EMPTY_CHARACTER);
            }

            return buffer_[pos];
        }

        constexpr const T &operator[](size_t pos) const
        {
            if (pos >= length_)
            {
                return EMPTY_CHARACTER;
            }

            return buffer_[pos];
        }

        operator const T *() const
        {
            return buffer_;
        }

        constexpr void clear() noexcept
        {
            length_ = 0;
            buffer_[0] = 0;
        }

        const T *c_str() const
        {
            return buffer_;
        }

        const T *data() const
        {
            return buffer_;
        }

        size_t size() const
        {
            return length_;
        }

        size_t length() const
        {
            return length_;
        }

        [[nodiscard]] constexpr bool empty() const noexcept
        {
            return length_ == 0;
        }

        basic_string<T> &operator+=(const T *value)
        {
            grow_buffer_for_string(value);

            basic_string<T>::length_ += minstd::min(strlcpy(basic_string<T>::buffer_ + basic_string<T>::length_, value, basic_string<T>::buffer_size_ - basic_string<T>::length_), basic_string<T>::max_size_ - basic_string<T>::length_);

            return *this;
        }

        basic_string<T> &append(const T *value, size_t length)
        {
            if (length == 0)
            {
                return *this;
            }

            grow_buffer(length + 1);

            size_t chars_copied = 0;

            while( value[chars_copied] != 0 && chars_copied < length && length_ < max_size_ - 1)
            {
                buffer_[length_++] = value[chars_copied++];
            }

            buffer_[length_] = 0;

            return *this;
        }

        constexpr const T &back() const
        {
            if (length_ == 0)
            {
                return EMPTY_CHARACTER;
            }

            return buffer_[length_ - 1];
        }

        constexpr bool push_back(T character)
        {
            if (basic_string<T>::length_ >= basic_string<T>::max_size_)
            {
                return false;
            }

            if (character == 0x00)
            {
                return true;
            }

            grow_buffer(1);

            basic_string<T>::buffer_[basic_string<T>::length_++] = character;
            basic_string<T>::buffer_[basic_string<T>::length_] = 0;

            return true;
        }

        constexpr void pop_back()
        {
            if (length_ > 0)
            {
                buffer_[--length_] = 0;
            }
        }

        constexpr basic_string &erase(size_t index = 0, size_t count = npos)
        {
            if (index >= length_)
            {
                return *this;
            }

            if ((count > length_) || ((index + count) > length_))
            {
                buffer_[index] = 0;
                length_ = index;
            }
            else
            {
                for (size_t i = index; i + count < length_; i++)
                {
                    buffer_[i] = buffer_[i + count];
                }

                length_ -= count;
                buffer_[length_] = 0;
            }

            return *this;
        }

        constexpr size_t find_last_of(T ch, size_t pos = npos) const noexcept
        {
            size_t search_start_index = (pos != npos) ? minstd::min(pos, length_) : length_;

            for (int i = search_start_index; i >= 0; i--)
            {
                if (buffer_[i] == ch)
                {
                    return i;
                }
            }

            return npos;
        }

        constexpr size_t find(const T *string_to_search_for, size_t pos = 0) const
        {
            char *location = strnstr(buffer_, string_to_search_for, length_);

            return location == NULL ? npos : location - buffer_;
        }

        constexpr size_t find(const T char_to_search_for, size_t pos = 0) const
        {
            for (size_t i = 0; i < length_; i++)
            {
                if (buffer_[i] == char_to_search_for)
                {
                    return i;
                }
            }

            return npos;
        }

        void substr(basic_string &substring, size_t pos = 0, size_t count = npos - 2) const
        {
            substring.grow_buffer(count);

            substring.length_ = minstd::min(strlcpy(substring.buffer_, buffer_ + minstd::min(pos, length_), minstd::min(count + 1, substring.buffer_size_)), minstd::min(count, substring.max_size_));
        }

    protected:
        T *buffer_;

        size_t buffer_size_;
        const size_t max_size_;

        size_t length_;

        const T EMPTY_CHARACTER = 0x00;

        explicit basic_string(T *buffer, size_t buffer_size, size_t max_size)
            : buffer_(buffer),
              buffer_size_(buffer_size),
              max_size_(max_size),
              length_(0)
        {
            buffer_[0] = 0;
        }

        explicit basic_string(T *buffer, size_t buffer_size, size_t max_size, const T *value)
            : buffer_(buffer),
              buffer_size_(buffer_size),
              max_size_(max_size)
        {
            length_ = minstd::min(strlcpy(buffer_, value, buffer_size_), max_size_);
        }

        explicit basic_string(T *buffer, size_t buffer_size, size_t max_size, const T *value, size_t length)
            : buffer_(buffer),
              buffer_size_(buffer_size),
              max_size_(max_size)
        {
            length_ = minstd::min(strlcpy(buffer_, value, minstd::min(buffer_size_, length + 1)), minstd::min(length, max_size_));
        }

        explicit basic_string(T *buffer, size_t buffer_size, size_t max_size, const basic_string &string_to_copy)
            : buffer_(buffer),
              buffer_size_(buffer_size),
              max_size_(max_size)
        {
            length_ = minstd::min(strlcpy(buffer_, string_to_copy.buffer_, buffer_size_), max_size_);
        }

        virtual void grow_buffer_for_string(const T *str) = 0;
        virtual void grow_buffer(size_t chars_needed) = 0;
    };

    using string = basic_string<char>;
}
