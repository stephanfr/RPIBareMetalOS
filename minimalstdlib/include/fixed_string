// Copyright 2023 Stephan Friedl. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#pragma once

#include "minstdconfig.h"

#include <string.h>
#include <stdint.h>

#include "allocator"
#include "algorithm"
#include "basic_string"

namespace MINIMAL_STD_NAMESPACE
{
    template <typename T, size_t MAX_SIZE> //  Default value for MAX_SIZE is in the forward declaration at the top of the file
    class basic_fixed_string : public basic_string<T>
    {
    public:
        static constexpr size_t npos = SIZE_MAX;

        explicit basic_fixed_string()
            : basic_string<T>(fixed_buffer_, MAX_SIZE+ 1, MAX_SIZE)
        {
        }

        basic_fixed_string(const T *value)
            : basic_string<T>(fixed_buffer_, MAX_SIZE+ 1, MAX_SIZE, value)
        {
        }

        explicit basic_fixed_string(const T *value, size_t length)
            : basic_string<T>(fixed_buffer_, MAX_SIZE+ 1, MAX_SIZE, value, length)
        {
        }

        explicit basic_fixed_string(const basic_string<T> &string_to_copy)
            : basic_string<T>(fixed_buffer_, MAX_SIZE+ 1, MAX_SIZE, string_to_copy)
        {
        }

        explicit basic_fixed_string(const basic_fixed_string &string_to_copy)
            : basic_string<T>(fixed_buffer_, MAX_SIZE+ 1, MAX_SIZE, string_to_copy.buffer_, string_to_copy.length_)
        {
        }

        virtual ~basic_fixed_string() = default;

        template <size_t OTHER_MAX_SIZE>
        basic_fixed_string<T, MAX_SIZE> &operator=(const basic_fixed_string<T, OTHER_MAX_SIZE> &string_to_copy)
        {
            basic_string<T>::length_ = minstd::min(strlcpy(basic_string<T>::buffer_, string_to_copy.data(), MAX_SIZE + 1), MAX_SIZE);

            return *this;
        }

        basic_fixed_string &operator=(const basic_string<T> &string_to_copy)
        {
            basic_string<T>::length_ = minstd::min(strlcpy(basic_string<T>::buffer_, string_to_copy.data(), MAX_SIZE + 1), MAX_SIZE);

            return *this;
        }

        basic_fixed_string &operator=(const T *string_to_copy)
        {
            basic_string<T>::length_ = minstd::min(strlcpy(basic_string<T>::buffer_, string_to_copy, MAX_SIZE + 1), MAX_SIZE);

            return *this;
        }

    private:
        union
        {
            uint64_t alignment_helper_; //  On aarch64 bare metal without the MMU, alignment matters.  This union forces alignment of the char array with a uint64_t which appears to work.
            T fixed_buffer_[MAX_SIZE + 1];
        };

        void grow_buffer_for_string(const T *str) override
        {}

        void grow_buffer(size_t chars_needed) override
        {};
    };


    template <typename T>
    template <size_t OTHER_MAX_SIZE>
    basic_string<T> &basic_string<T>::operator=(const basic_fixed_string<T, OTHER_MAX_SIZE> &string_to_copy)
    {
        basic_string<T>::length_ = minstd::min(strlcpy(basic_string<T>::buffer_, string_to_copy.buffer_, basic_string<T>::buffer_size_), basic_string<T>::max_size_);

        return *this;
    }

    //  Declare a fixed string class with the char data type

    template <size_t MAX_SIZE = DEFAULT_FIXED_STRING_MAX_SIZE>
    using fixed_string = basic_fixed_string<char, MAX_SIZE>;
}
