// Copyright 2023 Stephan Friedl. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#pragma once

#include "memory_heap"

#include "allocator"

namespace MINIMAL_STD_NAMESPACE
{

    template <typename T>
    class heap_allocator : public allocator<T>
    {
    public:
        heap_allocator(memory_heap&    heap,
                       size_t          max_size = __SIZE_MAX__)
            : heap_(heap),
              max_size_(max_size)
        {
        }

        size_t max_size() const noexcept override
        {
            return max_size_;
        }

        size_t current_size() const noexcept override
        {
            return current_size_;
        }

        T *allocate(size_t num_elements) override
        {
            if( current_size_ + num_elements > max_size_ )
            {
                return nullptr;
            }

            T* block = heap_.allocate_block<T>(num_elements);

            if(block != nullptr)
            {
                current_size_ += num_elements;
            }

            return block;
        }

        void deallocate(T *ptr, size_t num_elements) override
        {
            heap_.deallocate_block( ptr, num_elements );

            current_size_ -= num_elements;
        }

    private:
        memory_heap &heap_;

        size_t max_size_ = 0;
        size_t current_size_ = 0;
    };

}

